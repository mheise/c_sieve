Documentation for c_sieve

Contact info:  kaesees@gmail.com
Last Update:   15 Jul 2008



USAGE:
#include "sieve.h"

sieve_t my_sieve;
my_sieve = sieve(size_of_sieve);//expensive
/*	do stuff w/ sieve here - 
 *  each bit of the dynamic array 'my_sieve'
 *	contains a boolean value for whether the
 *	corresponding number is prime
 *  
 *  Note access must be done via getbit() and
 *  setbit()
 */
free(my_sieve);


COMPILE NOTES:
The sieve library is written using C99 features, and needs the standard C math
routines linked.

ex. 'gcc -std=c99 -lm -OBIGNUM my_sieve_prog.c'


PERFORMANCE:
The sieve routine is relatively fast, and scales well ( O(n), or damned close).
Some data from my machine ( C2D E6400 @2.67GHz, 2GB DDR):

time ./sieve_test 10000000  > /dev/null :  0.220s real
time ./sieve_test 100000000 > /dev/null :  4.079s real
time ./sieve_test 500000000 > /dev/null : 22.845s real


LIMITATIONS:
In its current configuration, the sieve routine is fast when the dataset is
smaller than the number of bits of available RAM; when your dataset gets
larger than that and swap space has to be used, things grind to a near-halt.
Trying to operate on a dataset larger than the number of bits of available
virtual memory, on the other hand, will cause the memory allocation at the
beginning of sieve() to fail, with perror(3) and exit(3) being called as a
result.  Finally, all sizes are handled internally using size_t; thus, if you
are on a typical 32-bit machine, incorrect behavior will occur if the sieve's
size is greater than about 4 billion.
